import express from 'express';
import request from 'supertest';
import jwt from 'jsonwebtoken';
import { requireAuth, createToken, getUserData } from './getUserData.js';
import cookieParser from 'cookie-parser';
import fetchMock from 'jest-fetch-mock';

const app = express();

// Middleware to parse cookies
app.use(cookieParser());

// Route that uses the requireAuth middleware
app.get('/', requireAuth, (req, res) => {
  res.status(200).json({ success: true, message: 'Access granted' });
});

jest.mock('jsonwebtoken', () => ({
  sign: jest.fn(),
  verify: jest.fn(),
}));

describe('Token and Auth Middleware Tests', () => {
  describe('createToken', () => {
    it('should call jwt.sign with the correct parameters', () => {
      const id = 'testUserId';
      const maxAge = 3 * 24 * 60 * 60;

      // Call createToken
      createToken(id);

      // Assert jwt.sign was called with the correct parameters
      expect(jwt.sign).toHaveBeenCalledWith({ id }, 'jwt-secret', {
        expiresIn: maxAge,
      });
    });

    it('should return the token generated by jwt.sign', () => {
      const id = 'testUserId';
      const token = 'mockedToken';

      // Mock the return value of jwt.sign
      jwt.sign.mockReturnValue(token);

      // Call createToken
      const result = createToken(id);

      // Assert that the result is the mocked token
      expect(result).toBe(token);
    });
  });

  describe('requireAuth Middleware', () => {
    it('should call next if the token is valid', async () => {
      const token = 'validToken';

      // Mock jwt.verify to call the callback with no error
      jwt.verify.mockImplementation((token, secret, callback) =>
        callback(null, { id: 'testUserId' }),
      );

      const response = await request(app)
        .get('/')
        .set('Cookie', `jwt=${token}`);

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        message: 'Access granted',
      });
    });

    it('should return an error if the token is invalid', async () => {
      const token = 'invalidToken';

      // Mock jwt.verify to call the callback with an error
      jwt.verify.mockImplementation((token, secret, callback) =>
        callback(new Error('Invalid token')),
      );

      const response = await request(app)
        .get('/')
        .set('Cookie', `jwt=${token}`);

      expect(response.status).toBe(500);
      expect(response.body).toEqual({
        success: false,
        message: 'Internal server error, Try again',
      });
    });

    it('should return an error if no token is provided', async () => {
      const response = await request(app).get('/');

      expect(response.status).toBe(500);
      expect(response.body).toEqual({
        success: false,
        message: 'Internal server error, Try again',
      });
    });
  });
});

fetchMock.enableMocks();

describe('getUserData', () => {
  beforeEach(() => {
    fetch.resetMocks();
  });

  it('should return user data when the request is successful', async () => {
    const mockAccessToken = 'mockAccessToken';
    const mockUserData = { id: 1, login: 'mockUser' };

    // Mock the fetch API to return a successful response
    fetch.mockResponseOnce(JSON.stringify(mockUserData));

    const data = await getUserData(mockAccessToken);

    expect(data).toEqual(mockUserData);
    expect(fetch).toHaveBeenCalledWith('https://api.github.com/user', {
      method: 'GET',
      headers: {
        Authorization: `token ${mockAccessToken}`,
      },
    });
  });

  it('should throw an error when the request fails', async () => {
    const mockAccessToken = 'mockAccessToken';

    // Mock the fetch API to return a failed response
    fetch.mockReject(new Error('Failed to fetch'));

    await expect(getUserData(mockAccessToken)).rejects.toThrow(
      'Failed to get user data',
    );
  });
});
